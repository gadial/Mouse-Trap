<!doctype html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8" />
    <title>Mouse Traph</title>
	<script type="text/javascript" src="js/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">


var game = new Phaser.Game(800, 600, Phaser.AUTO, 'phaser-example', { preload: preload, create: create, update: update, render: render });

function preload() {

    game.load.tilemap('map', 'assets/tilemaps/maps/level1.json', null, Phaser.Tilemap.TILED_JSON);
    game.load.image('Tiles', 'assets/tilemaps/tiles/tiles.png');
	game.load.spritesheet('mouse', 'assets/sprites/mouse.png', 56, 50);
	game.load.spritesheet('exit', 'assets/sprites/exit.png', 32, 51);
	game.load.spritesheet("tilesSprites", "assets/tilemaps/tiles/tiles.png", 32, 32);

}

var map;
var layer;
var platformLayer;
var solidLayer;
var goalLayer;
var marker;
var goals;
var exit;
var thorn;
var goal_count = 0;
// var sprite;
var cursors;
var currentDataString;

function findObjectsByType(targetType, tilemap, layer){
	var result = [];

	tilemap.objects[layer].forEach(function(element){
	  if(element.properties.type == targetType) {
		result.push(element);
	  }
	}, this);

	return result;
}

function eachTile(map, layer, func){
	layer = map.getLayer(layer);
	for (var y = 0; y < map.layers[layer].height; y++){
            for (var x = 0; x < map.layers[layer].width; x++){
                var tile = map.layers[layer].data[y][x];
				if (tile.index != -1){
					func(tile);
				}
			}
	}
}

function addTilesToGroup(map, layer, group, callback){
		eachTile(map, layer, function(tile){
			p = group.create(tile.worldX, tile.worldY, 'tilesSprites', tile.index - 1);
			p.body.immovable = true;
			if (callback !== undefined){
				callback(p);
			}
		});
}

function create() {

	game.stage.backgroundColor = '#2F8F8F';

    game.physics.startSystem(Phaser.Physics.ARCADE);

    map = game.add.tilemap('map');
    map.addTilesetImage('Tiles');

	solids = this.add.group();
	solids.enableBody = true;
	addTilesToGroup(map, 'Solid Layer', solids);
	addTilesToGroup(map, 'Platform Layer', solids, function(p){
		p.body.checkCollision.down = false;
		p.body.checkCollision.left = false;
		p.body.checkCollision.right = false;
	});
	addTilesToGroup(map, 'Sinking Platform Layer', solids, function(p){
		p.body.checkCollision.down = false;
		p.body.checkCollision.left = false;
		p.body.checkCollision.right = false;
		p.body.drag.y = 25;
		p.origin_y = p.y;
		p.is_sinking = true;
	});

	layer = map.createLayer('Tile Layer 1');
    layer.resizeWorld();
	
	goals = this.add.group();
	goals.enableBody = true;
	addTilesToGroup(map, 'Goal Layer', goals, function(){goal_count++});

	map.setCollisionByExclusion([], true, 'Solid Layer');
	
	var thornArr = findObjectsByType('thorn', map, 'Object Layer');
	thorn = game.add.sprite(thornArr[0].x, thornArr[0].y - 16, 'tilesSprites', thornArr[0].gid - 1);
	thorn.hazards = {left: true, right: true};
	game.physics.arcade.enable(thorn);
	thorn.body.immovable = true;
	
	var exitArr = findObjectsByType('exit', map, 'Object Layer');
	exit = game.add.sprite(exitArr[0].x, exitArr[0].y - 28, 'exit');
	game.physics.arcade.enable(exit);
//	exit.body.checkCollision.down = false;
//	exit.body.checkCollision.right = false;
//	exit.body.checkCollision.left = false;
	exit.body.immovable = true;
	exit.body.setSize(8,32,12,14);
	exit.open = false;
	exit.animations.add('exit',[2,3,4,5,0], 5, false);
	
	var playerArr = findObjectsByType('player', map, 'Object Layer');
	player = game.add.sprite(playerArr[0].x, playerArr[0].y - 32, 'mouse');
	player.status = 'alive';

    //  We need to enable physics on the player
    game.physics.arcade.enable(player);

    //  Player physics properties. Give the little guy a slight bounce.
    player.body.bounce.y = 0.2;
    player.body.gravity.y = 400;
	player.body.setSize(26, 48, 0, 0);
	player.body.horizontalFacing = Phaser.LEFT;
    player.body.collideWorldBounds = true;

    //  Our two animations, walking left and right.
    player.animations.add('left', [0, 1, 2, 3, 4, 5, 6, 7], 10, true);
    player.animations.add('right', [8, 9, 10, 11, 12, 13, 14, 15], 10, true);
	player.animations.add('die', [16,17,16,17,16,17,16,17,16,17,18,19,20,21,22], 10, false);

		
	cursors = game.input.keyboard.createCursorKeys();
    //  Our painting marker
    <!-- marker = game.add.graphics(); -->
    <!-- marker.lineStyle(2, 0xffffff, 1); -->
    <!-- marker.drawRect(0, 0, 32, 32); -->

    <!-- game.input.addMoveCallback(updateMarker, this); -->

    <!-- game.input.onDown.add(getTileProperties, this); -->

    <!-- cursors = game.input.keyboard.createCursorKeys(); -->
	
	

}

function getTileProperties() {

    var x = layer.getTileX(game.input.activePointer.worldX);
    var y = layer.getTileY(game.input.activePointer.worldY);

    var tile = map.getTile(x, y, layer);
    
    // Note: JSON.stringify will convert the object tile properties to a string
    currentDataString = JSON.stringify( tile.properties );

    tile.properties.wibble = true;

}

function updateMarker() {

    marker.x = layer.getTileX(game.input.activePointer.worldX) * 16;
    marker.y = layer.getTileY(game.input.activePointer.worldY) * 16;

}

function collectGoal(player, goal){
	//console.log("Goal touched! ", goal);
	goal.kill();
	goal_count--;
	if (goal_count == 0){
		open_exit();
	}
}

function open_exit(){
	exit.frame = 1;
	exit.open = true;
}

function collideWithSolid(player, solid){
	if (solid.is_sinking){
		if (player.y + 48 <= solid.y){ //check if the legs of the mouse are standing on top of the platform
			solid.body.velocity.y = 25;
			if (solid.origin_y + 20 <= solid.y){
				solid.kill();
			}
		}
	}
}


function isPlayerDown(player){
	return (player.body.blocked.down || player.body.touching.down);
}

function attemptExit(player, exit){
	if (exit.open){
		player.kill();
		exit.animations.play('exit');
	}
}

function terminatePlayer(player){
	player.status = 'dying';
	console.log("Terminate player ", player);
	player.body.enable = false
	player.animations.stop();
	player.animations.play('die');
}

function collideWithHazard(player, hazard){
	if (hazard.hazards.left && hazard.body.touching.left){
		console.log("Kill from left!");
		terminatePlayer(player)
	}
	if (hazard.hazards.right && hazard.body.touching.right){
		console.log("Kill from right!");
		terminatePlayer(player)
	}
	if (hazard.hazards.up && hazard.body.touching.up){
		console.log("Kill from up!");
		terminatePlayer(player)
	}
	if (hazard.hazards.down && hazard.body.touching.down){
		console.log("Kill from down!");
		terminatePlayer(player)
	}
}

function update() {
	game.physics.arcade.collide(player, solids, collideWithSolid);
	game.physics.arcade.collide(player, exit, attemptExit);
	game.physics.arcade.collide(player, thorn, collideWithHazard);
	game.physics.arcade.overlap(player, goals, collectGoal);
	if (player.status == 'alive'){
		if (isPlayerDown(player)){
			player.body.velocity.x = 0;
		}
		if (cursors.left.isDown)
		{
			//  Move to the left
			if (isPlayerDown(player)){
				if (player.body.horizontalFacing == Phaser.RIGHT){
					player.body.horizontalFacing = Phaser.LEFT;
					player.body.setSize(26, 48, 0, 0);
					player.body.x = player.body.x + 30;
				}
				player.animations.play('left');
			}
			player.body.velocity.x = -150;
		}
		else if (cursors.right.isDown)
		{
			//  Move to the right
			if (isPlayerDown(player)){
				if (player.body.horizontalFacing == Phaser.LEFT){
					player.body.horizontalFacing = Phaser.RIGHT;
					player.body.setSize(26, 48, 30, 0);
					player.body.x = player.body.x - 30;
				}
				player.animations.play('right');
			}
			player.body.velocity.x = 150;
		}
		else
		{
			//  Stand still
			player.animations.stop();
			if (player.body.horizontalFacing == Phaser.LEFT){
				player.frame = 5;
			}
			if (player.body.horizontalFacing == Phaser.RIGHT){
				player.frame = 14;
			}
		}
		if (!isPlayerDown(player)){
			player.animations.stop();  
		}		
		
		//  Allow the player to jump if they are touching the ground.
		if (cursors.up.isDown && isPlayerDown(player))
		{
			player.body.velocity.y = -200;
		}
	}
}

function render() {

   game.debug.bodyInfo(player, 32, 460);
//   game.debug.body(player);
//   game.debug.body(exit);
}
</script>

</body>
</html>